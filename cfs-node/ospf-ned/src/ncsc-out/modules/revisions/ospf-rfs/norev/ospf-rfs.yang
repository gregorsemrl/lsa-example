module ospf-rfs {
  // Generated by yanger -t ncs
  tailf:ncs-device-type "netconf";

  namespace "http://com/example/ospf-rfs";
  prefix ospf-rfs;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-ncs {
    prefix ncs;
  }
  import tailf-common {
    prefix tailf;
  }

  augment "/ncs:devices/ncs:device/ncs:config" {
    list ospf-rfs {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='ospf-rfs']";
      tailf:info
        "Services for OSPF configuration (NSO300 LSA training)";
      key "name";
      // NCS drop tailf:callpoint
      tailf:action check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device config is according to the service";
        description
          "Check if this service has been undermined, i.e., if this service
           was to be re-deployed, would it do anything. This action will
           invoke the FASTMAP code to create the change set that is compared
           to the existing data in CDB locally.

           If outformat is boolean, 'true' is returned if the service is
           in sync, i.e., a re-deploy would do nothing. If outformat is
           cli or xml, the changes that the service would do to the
           network if re-deployed are returned.";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat4;
            default "boolean";
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            default "deep";
          }
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            leaf in-sync {
              type boolean;
            }
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
        }
      }
      tailf:action deep-check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device config is according to the service";
        description
          "Check if this service has been undermined on the device itself.
           The action 'check-sync' compares the output of the service
           code to what is stored in CDB locally. This action retrieves the
           configuration from the devices touched by the service and compares
           the forward diff set of the service to the retrieved data. This
           is thus a fairly heavy weight operation. As opposed to the check-sync
           action that invokes the FASTMAP code, this action re-applies the
           forward diff-set. This is the same output you see when inspecting
           the 'get-modifications' operational field in the service instance.

           If the device is in sync with CDB, the output of this action
           is identical to the output of the cheaper check-sync action";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat-deep-check-sync;
            default "boolean";
          }
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                container local-node {
                  anyxml data;
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-sync {
              container sync-result {
                container local-node {
                  leaf in-sync {
                    type boolean;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf in-sync {
                    type boolean;
                  }
                }
              }
            }
          }
        }
      }
      tailf:action re-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Run/Dry-run the service logic again";
        description
          "Run the service code again, possibly writing the changes of
           the service to the network once again. If the dry-run option is used,
           the action simply reports (in different formats) what it would do.

           Use the option 'reconcile' if the service should reconcile
           original data, i.e., take control of that data.  This option
           acknowledges other services controlling the same data.  The
           reference count will indicate how many services control the
           data.";
        // NCS drop tailf:actionpoint
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type ncs:outformat3;
            }
          }
          leaf no-revision-drop {
            type empty;
            description
              "This flags means that NCS will not run its data model revision
               algorithm, which requires all participating managed devices
               to have all parts of the data models for all data contained
               in this transaction. Thus, this flag forces NCS to never
               silently drop any data set operations towards a device.";
          }
          leaf no-networking {
            type empty;
            description
              "Do not send any data to the devices. Even if the transaction
               manipulates data below /devices/device/config, nothing will
               be sent to the managed devices. This is a way to manipulate
               CDB in NCS without generating any southbound traffic.";
          }
          choice choice-sync-check {
            leaf no-overwrite {
              type empty;
              description
                "This flags means that NCS will check that the data that
                 should be modified has not changed on the device compared
                 to NCS's view of the data. This is a fine-granular sync check;
                 NCS verifies that NCS and the device is in sync regarding
                 the data that will be modified. If they are not in sync,
                 the transaction is aborted.";
            }
            leaf no-out-of-sync-check {
              type empty;
              description
                "Continue with the transaction even if NCS detects that a device's
                 configuration is out of sync. The device's sync state is assumed
                 to be unknown after such commit and the stored transaction id
                 value is cleared";
            }
          }
          container commit-queue {
            presence "Commit through the commit queue";
            leaf tag {
              type string;
              description
                "User defined opaque tag.
                 The tag is present in all notifications and events
                 sent referencing the specific queue item.";
            }
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.

                   Note that this flag has no effect if
                   /devices/commit-queue/enabled-by-default is 'true', since all
                   commits go through the queue in this case.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  default "infinity";
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.

                       If the timeout is not set, the operation waits until the
                       transaction is committed.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.
                       This is the default";
                    type empty;
                  }
                }
              }
              default "async";
            }
            leaf block-others {
              type empty;
              description
                "The resulting queue item will block subsequent queue items,
                 which use any of the devices in this queue item, from
                 being queued.";
            }
            leaf lock {
              type empty;
              description
                "Place a lock on the resulting queue item. The queue
                 item will not be processed until it has been unlocked,
                 see the actions 'unlock' and 'lock' in
                 /devices/commit-queue/queue-item'.

                 No following queue items, using the same devices, will be
                 allowed to execute as long as the lock is in place.";
            }
            leaf atomic {
              type boolean;
              description
                "Sets the atomic behaviour of the resulting queue item.
                 If this is set to false, the devices contained in the
                 resulting queue item can start executing if the same devices
                 in other non-atomic queue items ahead of it in the queue are
                 completed. If set to true, the atomic integrity of the
                 queue item is preserved.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue item will roll back on errors. The commit
                     queue will place a lock with 'block-others' on the devices and
                     services in the failed queue item. The rollback action will then
                     automatically be invoked when the queue item has finished
                     its execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock with 'block-others'
                     on the devices and services in the failed queue item. The
                     lock must then either manually be released when the error
                     is fixed or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling of the LSA nodes as such. This flag tells
                 NCS to propagate applicable commit flags and actions
                 to the LSA nodes without applying them on the upper
                 NCS node itself. The commit flags affected are
                 'dry-run', 'no-networking', 'no-out-of-sync-check',
                 'no-overwrite' and 'no-revision-drop'.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            default "deep";
          }
          container reconcile {
            description
              "Reconcile the service data.  All data which existed before
               the service was created will now be owned by the service.
               When the service is removed that data will also be removed.
               In technical terms the reference count will be decreased
               by one for everything which existed prior to the service.

               If manually configured data exists below in the configuration
               tree that data is kept unless the option
               'discard-non-service-config' is used.";
            presence "";
            choice c-non-service-config {
              leaf keep-non-service-config {
                type empty;
              }
              leaf discard-non-service-config {
                type empty;
              }
              default "keep-non-service-config";
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      tailf:action reactive-re-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Reactive redeploy of service logic";
        description
          "This is a tailored re-deploy intended to be used in the reactive
           FASTMAP scenario. It differs from the ordinary re-deploy in that
           this action does not take any input parameters.

           This action will re-deploy the services as an
           'shallow' depth re-deploy. It will be performed as the same
           user as the original commit. Also, the commit parameters will be
           identical to the latest commit involving this service.

           By default this action is asynchronous and returns nothing.";
        // NCS drop tailf:actionpoint
        input {
          leaf sync {
            description
              "By default the action is asynchronous, i.e. it does not wait for
               the service to be re-deployed. Use this leaf to get synchronous
               behaviour and block until the service re-deploy transaction is
               committed. It also means that the action will possibly return
               ncs-commit-result (such as commit-queue id if any) and return an
               error if the transaction failed.";
            type empty;
          }
        }
        output {
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      tailf:action touch {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Touch a service";
        description
          "This action marks the service as changed.

           Executing the action touch followed by a commit is the same as
           executing the action 're-deploy shallow'.

           By using the action 'touch' several re-deploys can be performed
           in the same transaction.";
        // NCS drop tailf:actionpoint
        input;
        output;
      }
      // NCS drop config false container modified
      // NCS drop config false container 'directly-modified'
      tailf:action get-modifications {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Get the data this service created";
        description
          "Returns the data this service modified, either
           in CLI diff format, or XML edit-config format. This
           data is only available if the parameter
           '/services/global-settings/collect-forward-diff' is set to true.

           If the parameter 'reverse' is given the modifications needed
           to 'reverse' the effect of the service is shown. This will
           be applied if the service is deleted. This data is always
           available.

           The parameter deep/shallow controls if the modifications shown
           are for this service only or for all modiefied services as well.";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat2;
          }
          leaf reverse {
            type empty;
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            default "deep";
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                container local-node {
                  anyxml data;
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
        }
      }
      // NCS drop config false leaf-list 'device-list'
      tailf:action un-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Undo the effects of this service instance but keep the
           service itself. The service can later be re-deployed. This is
           a means to deactivate a service, but keep it in the system.";
        tailf:info
          "Undo the effects of this service";
        // NCS drop tailf:actionpoint
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type ncs:outformat3;
            }
          }
          leaf no-revision-drop {
            type empty;
            description
              "This flags means that NCS will not run its data model revision
               algorithm, which requires all participating managed devices
               to have all parts of the data models for all data contained
               in this transaction. Thus, this flag forces NCS to never
               silently drop any data set operations towards a device.";
          }
          leaf no-networking {
            type empty;
            description
              "Do not send any data to the devices. Even if the transaction
               manipulates data below /devices/device/config, nothing will
               be sent to the managed devices. This is a way to manipulate
               CDB in NCS without generating any southbound traffic.";
          }
          choice choice-sync-check {
            leaf no-overwrite {
              type empty;
              description
                "This flags means that NCS will check that the data that
                 should be modified has not changed on the device compared
                 to NCS's view of the data. This is a fine-granular sync check;
                 NCS verifies that NCS and the device is in sync regarding
                 the data that will be modified. If they are not in sync,
                 the transaction is aborted.";
            }
            leaf no-out-of-sync-check {
              type empty;
              description
                "Continue with the transaction even if NCS detects that a device's
                 configuration is out of sync. The device's sync state is assumed
                 to be unknown after such commit and the stored transaction id
                 value is cleared";
            }
          }
          container commit-queue {
            presence "Commit through the commit queue";
            leaf tag {
              type string;
              description
                "User defined opaque tag.
                 The tag is present in all notifications and events
                 sent referencing the specific queue item.";
            }
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.

                   Note that this flag has no effect if
                   /devices/commit-queue/enabled-by-default is 'true', since all
                   commits go through the queue in this case.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  default "infinity";
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.

                       If the timeout is not set, the operation waits until the
                       transaction is committed.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.
                       This is the default";
                    type empty;
                  }
                }
              }
              default "async";
            }
            leaf block-others {
              type empty;
              description
                "The resulting queue item will block subsequent queue items,
                 which use any of the devices in this queue item, from
                 being queued.";
            }
            leaf lock {
              type empty;
              description
                "Place a lock on the resulting queue item. The queue
                 item will not be processed until it has been unlocked,
                 see the actions 'unlock' and 'lock' in
                 /devices/commit-queue/queue-item'.

                 No following queue items, using the same devices, will be
                 allowed to execute as long as the lock is in place.";
            }
            leaf atomic {
              type boolean;
              description
                "Sets the atomic behaviour of the resulting queue item.
                 If this is set to false, the devices contained in the
                 resulting queue item can start executing if the same devices
                 in other non-atomic queue items ahead of it in the queue are
                 completed. If set to true, the atomic integrity of the
                 queue item is preserved.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue item will roll back on errors. The commit
                     queue will place a lock with 'block-others' on the devices and
                     services in the failed queue item. The rollback action will then
                     automatically be invoked when the queue item has finished
                     its execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock with 'block-others'
                     on the devices and services in the failed queue item. The
                     lock must then either manually be released when the error
                     is fixed or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling of the LSA nodes as such. This flag tells
                 NCS to propagate applicable commit flags and actions
                 to the LSA nodes without applying them on the upper
                 NCS node itself. The commit flags affected are
                 'dry-run', 'no-networking', 'no-out-of-sync-check',
                 'no-overwrite' and 'no-revision-drop'.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
          leaf ignore-refcount {
            type empty;
            description
              "Unconditionally delete the device data created by the
               service, regardless of the refcount.";
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      // NCS drop config false leaf-list 'used-by-customer-service'
      // NCS drop config false container 'commit-queue'
      container private {
        description
          "NCS service related internal data stored here.";
        tailf:hidden "fastmap-private";
        // NCS drop fully hidden leaf 'diff-set'
        // NCS drop fully hidden leaf 'forward-diff-set'
        // NCS drop fully hidden leaf-list 'device-list'
        // NCS drop fully hidden leaf-list 'service-list'
        // NCS drop fully hidden leaf-list 'lsa-service-list'
        container property-list {
          description
            "FASTMAP service instance data used by the service implementation.";
          list property {
            key "name";
            leaf name {
              type string;
            }
            leaf value {
              type string;
            }
          }
        }
        leaf re-deploy-counter {
          type int32;
          default "0";
        }
        // NCS drop fully hidden leaf 'latest-commit-params'
        // NCS drop fully hidden leaf 'latest-u-info'
      }
      // NCS drop config false container log
      ncs:lsa-service;
      leaf name {
        type string;
      }
      list device {
        tailf:info
          "List of devices where OSPF is configured";
        key "name";
        leaf name {
          tailf:info
            "Device name";
          type string;
        }
        list ospfProcess {
          tailf:info
            "OSPF Configuration list";
          key "id";
          leaf id {
            tailf:info
              "OSPF Process ID";
            type uint32;
          }
          leaf ip-address {
            tailf:info
              "OSPF IP address";
            type inet:ipv4-address;
          }
          leaf netmask {
            tailf:info
              "OSPF Netmask";
            type inet:ipv4-address;
          }
          leaf area {
            tailf:info
              "OSPF Area ID";
            type uint32;
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:device/ncs:live-status" {
    list ospf-rfs {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='ospf-rfs'] or (../ncs:live-status-protocol[not(ncs:capability)]) or (../ncs:live-status-protocol/ncs:capability/ncs:module[.='ospf-rfs'])";
      tailf:info
        "Services for OSPF configuration (NSO300 LSA training)";
      key "name";
      // NCS drop tailf:callpoint
      tailf:action check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device config is according to the service";
        description
          "Check if this service has been undermined, i.e., if this service
           was to be re-deployed, would it do anything. This action will
           invoke the FASTMAP code to create the change set that is compared
           to the existing data in CDB locally.

           If outformat is boolean, 'true' is returned if the service is
           in sync, i.e., a re-deploy would do nothing. If outformat is
           cli or xml, the changes that the service would do to the
           network if re-deployed are returned.";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat4;
            // NCS drop default statement
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            // NCS drop default statement
          }
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            leaf in-sync {
              type boolean;
            }
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
        }
      }
      tailf:action deep-check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device config is according to the service";
        description
          "Check if this service has been undermined on the device itself.
           The action 'check-sync' compares the output of the service
           code to what is stored in CDB locally. This action retrieves the
           configuration from the devices touched by the service and compares
           the forward diff set of the service to the retrieved data. This
           is thus a fairly heavy weight operation. As opposed to the check-sync
           action that invokes the FASTMAP code, this action re-applies the
           forward diff-set. This is the same output you see when inspecting
           the 'get-modifications' operational field in the service instance.

           If the device is in sync with CDB, the output of this action
           is identical to the output of the cheaper check-sync action";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat-deep-check-sync;
            // NCS drop default statement
          }
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                container local-node {
                  anyxml data;
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-sync {
              container sync-result {
                container local-node {
                  leaf in-sync {
                    type boolean;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf in-sync {
                    type boolean;
                  }
                }
              }
            }
          }
        }
      }
      tailf:action re-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Run/Dry-run the service logic again";
        description
          "Run the service code again, possibly writing the changes of
           the service to the network once again. If the dry-run option is used,
           the action simply reports (in different formats) what it would do.

           Use the option 'reconcile' if the service should reconcile
           original data, i.e., take control of that data.  This option
           acknowledges other services controlling the same data.  The
           reference count will indicate how many services control the
           data.";
        // NCS drop tailf:actionpoint
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type ncs:outformat3;
            }
          }
          leaf no-revision-drop {
            type empty;
            description
              "This flags means that NCS will not run its data model revision
               algorithm, which requires all participating managed devices
               to have all parts of the data models for all data contained
               in this transaction. Thus, this flag forces NCS to never
               silently drop any data set operations towards a device.";
          }
          leaf no-networking {
            type empty;
            description
              "Do not send any data to the devices. Even if the transaction
               manipulates data below /devices/device/config, nothing will
               be sent to the managed devices. This is a way to manipulate
               CDB in NCS without generating any southbound traffic.";
          }
          choice choice-sync-check {
            leaf no-overwrite {
              type empty;
              description
                "This flags means that NCS will check that the data that
                 should be modified has not changed on the device compared
                 to NCS's view of the data. This is a fine-granular sync check;
                 NCS verifies that NCS and the device is in sync regarding
                 the data that will be modified. If they are not in sync,
                 the transaction is aborted.";
            }
            leaf no-out-of-sync-check {
              type empty;
              description
                "Continue with the transaction even if NCS detects that a device's
                 configuration is out of sync. The device's sync state is assumed
                 to be unknown after such commit and the stored transaction id
                 value is cleared";
            }
          }
          container commit-queue {
            presence "Commit through the commit queue";
            leaf tag {
              type string;
              description
                "User defined opaque tag.
                 The tag is present in all notifications and events
                 sent referencing the specific queue item.";
            }
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.

                   Note that this flag has no effect if
                   /devices/commit-queue/enabled-by-default is 'true', since all
                   commits go through the queue in this case.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  // NCS drop default statement
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.

                       If the timeout is not set, the operation waits until the
                       transaction is committed.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.
                       This is the default";
                    type empty;
                  }
                }
              }
              // NCS drop default statement
            }
            leaf block-others {
              type empty;
              description
                "The resulting queue item will block subsequent queue items,
                 which use any of the devices in this queue item, from
                 being queued.";
            }
            leaf lock {
              type empty;
              description
                "Place a lock on the resulting queue item. The queue
                 item will not be processed until it has been unlocked,
                 see the actions 'unlock' and 'lock' in
                 /devices/commit-queue/queue-item'.

                 No following queue items, using the same devices, will be
                 allowed to execute as long as the lock is in place.";
            }
            leaf atomic {
              type boolean;
              description
                "Sets the atomic behaviour of the resulting queue item.
                 If this is set to false, the devices contained in the
                 resulting queue item can start executing if the same devices
                 in other non-atomic queue items ahead of it in the queue are
                 completed. If set to true, the atomic integrity of the
                 queue item is preserved.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue item will roll back on errors. The commit
                     queue will place a lock with 'block-others' on the devices and
                     services in the failed queue item. The rollback action will then
                     automatically be invoked when the queue item has finished
                     its execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock with 'block-others'
                     on the devices and services in the failed queue item. The
                     lock must then either manually be released when the error
                     is fixed or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling of the LSA nodes as such. This flag tells
                 NCS to propagate applicable commit flags and actions
                 to the LSA nodes without applying them on the upper
                 NCS node itself. The commit flags affected are
                 'dry-run', 'no-networking', 'no-out-of-sync-check',
                 'no-overwrite' and 'no-revision-drop'.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            // NCS drop default statement
          }
          container reconcile {
            description
              "Reconcile the service data.  All data which existed before
               the service was created will now be owned by the service.
               When the service is removed that data will also be removed.
               In technical terms the reference count will be decreased
               by one for everything which existed prior to the service.

               If manually configured data exists below in the configuration
               tree that data is kept unless the option
               'discard-non-service-config' is used.";
            presence "";
            choice c-non-service-config {
              leaf keep-non-service-config {
                type empty;
              }
              leaf discard-non-service-config {
                type empty;
              }
              // NCS drop default statement
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      tailf:action reactive-re-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Reactive redeploy of service logic";
        description
          "This is a tailored re-deploy intended to be used in the reactive
           FASTMAP scenario. It differs from the ordinary re-deploy in that
           this action does not take any input parameters.

           This action will re-deploy the services as an
           'shallow' depth re-deploy. It will be performed as the same
           user as the original commit. Also, the commit parameters will be
           identical to the latest commit involving this service.

           By default this action is asynchronous and returns nothing.";
        // NCS drop tailf:actionpoint
        input {
          leaf sync {
            description
              "By default the action is asynchronous, i.e. it does not wait for
               the service to be re-deployed. Use this leaf to get synchronous
               behaviour and block until the service re-deploy transaction is
               committed. It also means that the action will possibly return
               ncs-commit-result (such as commit-queue id if any) and return an
               error if the transaction failed.";
            type empty;
          }
        }
        output {
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      tailf:action touch {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Touch a service";
        description
          "This action marks the service as changed.

           Executing the action touch followed by a commit is the same as
           executing the action 're-deploy shallow'.

           By using the action 'touch' several re-deploys can be performed
           in the same transaction.";
        // NCS drop tailf:actionpoint
        input;
        output;
      }
      container modified {
        // NCS drop tailf:callpoint
        description
          "Devices and other services this service has modified directly or
           indirectly (through another service).";
        tailf:info
          "Devices and other services this service modified directly or
           indirectly.";
        leaf-list devices {
          tailf:info
            "Devices this service modified directly or indirectly";
          type string;
        }
        leaf-list services {
          tailf:info
            "Services this service modified directly or indirectly";
          type string;
        }
        leaf-list lsa-services {
          tailf:info
            "Services residing on remote LSA nodes this service
             has modified directly or indirectly.";
          type string;
        }
      }
      container directly-modified {
        // NCS drop tailf:callpoint
        description
          "Devices and other services this service has explicitly
           modified.";
        tailf:info
          "Devices and other services this service has explicitly
           modified.";
        leaf-list devices {
          tailf:info
            "Devices this service has explicitly modified.";
          type string;
        }
        leaf-list services {
          tailf:info
            "Services this service has explicitly modified.";
          type string;
        }
        leaf-list lsa-services {
          tailf:info
            "Services residing on remote LSA nodes this service
             has explicitly modified.";
          type string;
        }
      }
      tailf:action get-modifications {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Get the data this service created";
        description
          "Returns the data this service modified, either
           in CLI diff format, or XML edit-config format. This
           data is only available if the parameter
           '/services/global-settings/collect-forward-diff' is set to true.

           If the parameter 'reverse' is given the modifications needed
           to 'reverse' the effect of the service is shown. This will
           be applied if the service is deleted. This data is always
           available.

           The parameter deep/shallow controls if the modifications shown
           are for this service only or for all modiefied services as well.";
        // NCS drop tailf:actionpoint
        input {
          leaf outformat {
            type ncs:outformat2;
          }
          leaf reverse {
            type empty;
          }
          choice depth {
            leaf deep {
              type empty;
            }
            leaf shallow {
              type empty;
            }
            // NCS drop default statement
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling LSA nodes as such.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                container local-node {
                  anyxml data;
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-service {
                  key "service-id";
                  leaf service-id {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
        }
      }
      leaf-list device-list {
        tailf:info
          "A list of devices this service instance has manipulated";
        type string;
        status deprecated;
        description
          "A list of managed devices this service instance has manipulated.

           This leaf is deprecated. Use 'modified' instead.";
        // NCS drop tailf:callpoint
      }
      tailf:action un-deploy {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Undo the effects of this service instance but keep the
           service itself. The service can later be re-deployed. This is
           a means to deactivate a service, but keep it in the system.";
        tailf:info
          "Undo the effects of this service";
        // NCS drop tailf:actionpoint
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type ncs:outformat3;
            }
          }
          leaf no-revision-drop {
            type empty;
            description
              "This flags means that NCS will not run its data model revision
               algorithm, which requires all participating managed devices
               to have all parts of the data models for all data contained
               in this transaction. Thus, this flag forces NCS to never
               silently drop any data set operations towards a device.";
          }
          leaf no-networking {
            type empty;
            description
              "Do not send any data to the devices. Even if the transaction
               manipulates data below /devices/device/config, nothing will
               be sent to the managed devices. This is a way to manipulate
               CDB in NCS without generating any southbound traffic.";
          }
          choice choice-sync-check {
            leaf no-overwrite {
              type empty;
              description
                "This flags means that NCS will check that the data that
                 should be modified has not changed on the device compared
                 to NCS's view of the data. This is a fine-granular sync check;
                 NCS verifies that NCS and the device is in sync regarding
                 the data that will be modified. If they are not in sync,
                 the transaction is aborted.";
            }
            leaf no-out-of-sync-check {
              type empty;
              description
                "Continue with the transaction even if NCS detects that a device's
                 configuration is out of sync. The device's sync state is assumed
                 to be unknown after such commit and the stored transaction id
                 value is cleared";
            }
          }
          container commit-queue {
            presence "Commit through the commit queue";
            leaf tag {
              type string;
              description
                "User defined opaque tag.
                 The tag is present in all notifications and events
                 sent referencing the specific queue item.";
            }
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.

                   Note that this flag has no effect if
                   /devices/commit-queue/enabled-by-default is 'true', since all
                   commits go through the queue in this case.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  // NCS drop default statement
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.

                       If the timeout is not set, the operation waits until the
                       transaction is committed.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.
                       This is the default";
                    type empty;
                  }
                }
              }
              // NCS drop default statement
            }
            leaf block-others {
              type empty;
              description
                "The resulting queue item will block subsequent queue items,
                 which use any of the devices in this queue item, from
                 being queued.";
            }
            leaf lock {
              type empty;
              description
                "Place a lock on the resulting queue item. The queue
                 item will not be processed until it has been unlocked,
                 see the actions 'unlock' and 'lock' in
                 /devices/commit-queue/queue-item'.

                 No following queue items, using the same devices, will be
                 allowed to execute as long as the lock is in place.";
            }
            leaf atomic {
              type boolean;
              description
                "Sets the atomic behaviour of the resulting queue item.
                 If this is set to false, the devices contained in the
                 resulting queue item can start executing if the same devices
                 in other non-atomic queue items ahead of it in the queue are
                 completed. If set to true, the atomic integrity of the
                 queue item is preserved.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue item will roll back on errors. The commit
                     queue will place a lock with 'block-others' on the devices and
                     services in the failed queue item. The rollback action will then
                     automatically be invoked when the queue item has finished
                     its execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock with 'block-others'
                     on the devices and services in the failed queue item. The
                     lock must then either manually be released when the error
                     is fixed or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
          choice choice-lsa {
            leaf use-lsa {
              type empty;
              description
                "Force handling of the LSA nodes as such. This flag tells
                 NCS to propagate applicable commit flags and actions
                 to the LSA nodes without applying them on the upper
                 NCS node itself. The commit flags affected are
                 'dry-run', 'no-networking', 'no-out-of-sync-check',
                 'no-overwrite' and 'no-revision-drop'.";
            }
            leaf no-lsa {
              type empty;
              description
                "Do not handle any of the LSA nodes as such. These nodes
                 will be handled as any other device.";
            }
          }
          leaf ignore-refcount {
            type empty;
            description
              "Unconditionally delete the device data created by the
               service, regardless of the refcount.";
          }
        }
        output {
          choice outformat {
            case case-xml {
              container result-xml {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in NETCONF XML edit-config format,
                   i.e., the edit-config that would be applied locally (at NCS)
                   to get a config that is equal to that of the managed device.";
                container local-node {
                  anyxml data;
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  anyxml data;
                }
              }
            }
            case case-cli {
              container cli {
                description
                  "Display all changes in the whole data model. The
                   changes will be displayed in CLI curly bracket format.";
                container local-node {
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
                list lsa-node {
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
            case case-native {
              container native {
                description
                  "Display only changes under /devices/device/config. The
                   changes will be displayed in native device format.";
                list device {
                  key "name";
                  leaf name {
                    type string;
                  }
                  leaf data {
                    tailf:cli-preformatted;
                    type string;
                  }
                }
              }
            }
          }
          container commit-queue {
            leaf id {
              type string;
              description
                "This leaf is returned if 'commit-queue/async' or
                 'commit-queue/sync' was given in the input parameters.";
            }
            leaf status {
              type enumeration {
                enum "async" {
                  description
                    "The queue item was successfully created.";
                  tailf:code-name "commit_cq_async";
                }
                enum "completed" {
                  description
                    "The queue item was successfully completed.";
                  tailf:code-name "commit_cq_completed";
                }
                enum "timeout" {
                  description
                    "The timer expired before the queue item was completed.";
                  tailf:code-name "commit_cq_timeout";
                }
                enum "deleted" {
                  description
                    "The queue item was deleted from the queue.";
                  tailf:code-name "commit_cq_deleted";
                }
                enum "failed" {
                  description
                    "The queue item failed.";
                  tailf:code-name "commit_cq_failed";
                }
              }
            }
            list failed-device {
              key "name";
              leaf name {
                type string;
              }
              leaf reason {
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
          }
        }
      }
      leaf-list used-by-customer-service {
        tailf:info
          "Customer facing services using this service";
        type string;
        // NCS drop tailf:callpoint
      }
      container commit-queue {
        // NCS drop tailf:cdb-oper
        tailf:action clear {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Clear the service commit queue of all queue items.
             If this action is invoked for an queue-items which has other states
             than 'failed' those items migth later reappear since this service
             is then still affected by active commit queue transactions";
          // NCS drop tailf:actionpoint
        }
        list queue-item {
          key "id";
          leaf id {
            type uint64;
            description
              "If the queue item in the commit queue refers to this service
               this is the queue number.";
          }
          description
            "When a service is committed through the commit queue, these
             fields act as references regarding the state of this service
             instance. In the worst case scenario, a service instance is
             in the 'failed' state. This means that parts of the queued
             commit failed.

             If a service gets committed through the commit queue and the
             commit fails, the backpointers in the service data are
             followed and the affected service instances are updated and
             set to the 'failed' state.

             Depending on the nature of the failure, different techniques
             to reconcile the service can be used.

             - Make sure the commit queue is blocked to not interfere
               with the error recovery procedure.
               Do a sync-from on the non-completed device(s) and then
               re-deploy the failed service(s) with the
               'reconcile' option to reconcile original data,
               i.e., take control of that data. This option
               acknowledges other services controlling the same data.
               The reference count will indicate how many services control
               the data. Release any queue lock that was created.

             - Make sure the commit queue is blocked to not interfere
               with the error recovery procedure.
               Use un-deploy with the no-networking option on the
               service and then do sync-from on the non-completed
               device(s). Make sure the error is fixed and then
               re-deploy the failed service(s) with the
               'reconcile' option. Release any queue lock
               that was created.

             In the 'failed' state, these fields are reset if a new
             commit queue transaction is affecting this service, or
             the service is re-deployed, or these fields are deleted
             using the specific purge action.
             In other cases the 'failed' state will remain.";
          leaf status {
            // NCS drop tailf:callpoint
            type enumeration {
              enum "waiting" {
                description
                  "This service was committed through the commit queue
                   and the data is in the queue, waiting to run.";
              }
              enum "executing" {
                description
                  "The data for this service is currently executing at the
                   head of the commit queue.";
              }
              enum "blocking" {
                description
                  "One or more of the devices for the transaction
                   of which this service instance is a part, exposes a
                   transient error.  The queue item in the commit queue
                   remains there until the device becomes operational
                   or the queue is pruned.

                   Examples of transient errors are connection failures
                   and that if thre changes are rejected due to the device
                   being locked.

                   The status for the queue item, in
                   /devices/commit-queue/queue-item, contains details
                   about this state.";
              }
              enum "blocked" {
                description
                  "The data for this service is waiting in the queue, and some
                   other queue item ahead of this item is in state 'blocking'.";
              }
              enum "failed" {
                description
                  "The data for the transaction was not successfully
                   deployed on all devices.  This service is is not
                   operational.

                   Details about the error can be found in the
                   'failed-device' list.

                   The queue item itself is removed from the
                   /devices/commit-queue/queue-item list when it fails.";
                tailf:code-name "service_failed";
              }
              enum "admin-cleared" {
                description
                  "The queue item affecting this service has been administratively
                   cleared. Either directly by a clear action on this service
                   commit queue data, or indirectly because of a delete/prune
                   action directly on the commit queue queue-item.

                   In either case, device data for this service may or may not
                   have been deployed in the network.";
              }
              enum "commit-queue-failed" {
                description
                  "The data for the transaction was not successfully
                   deployed on all devices. Since serveral services where modified
                   by this transaction, whether this service is operational or
                   not is indecisive.

                   Details about the error can be found in the
                   'failed-device' list.

                   The queue item itself is removed from the
                   /devices/commit-queue/queue-item list when it fails.";
              }
            }
          }
          // NCS drop fully hidden leaf 'cleared-by-admin'
          // NCS drop fully hidden leaf 'no-of-impacted-services'
          list failed-device {
            description
              "If the 'status' leaf is 'failed', this list contains detailed
               information on the devices that were responsible for the
               error of the commit queue item.";
            key "name";
            leaf name {
              type string;
            }
            leaf time {
              type string;
              description
                "Time when the failure occured.";
            }
            leaf config-data {
              description
                "The configuration data that was rejected by the device
                 in XML format.";
              tailf:cli-preformatted;
              type string;
            }
            leaf error {
              description
                "The error returned by the device.";
              type string;
            }
          }
          tailf:action admin-clear {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Administratively clear this item.
               Information about failed devices will remain for this service.";
            // NCS drop tailf:actionpoint
          }
          tailf:action delete {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Delete this item.
               If this action is invoked for an item which is in other states
               than 'failed' this data migth later reappear since this service
               is then still affected by an active commit queue transaction";
            // NCS drop tailf:actionpoint
          }
        }
      }
      container private {
        description
          "NCS service related internal data stored here.";
        tailf:hidden "fastmap-private";
        // NCS drop fully hidden leaf 'diff-set'
        // NCS drop fully hidden leaf 'forward-diff-set'
        // NCS drop fully hidden leaf-list 'device-list'
        // NCS drop fully hidden leaf-list 'service-list'
        // NCS drop fully hidden leaf-list 'lsa-service-list'
        container property-list {
          description
            "FASTMAP service instance data used by the service implementation.";
          list property {
            key "name";
            leaf name {
              type string;
            }
            leaf value {
              type string;
            }
          }
        }
        leaf re-deploy-counter {
          type int32;
          // NCS drop default statement
        }
        // NCS drop fully hidden leaf 'latest-commit-params'
        // NCS drop fully hidden leaf 'latest-u-info'
      }
      container log {
        // NCS drop tailf:cdb-oper
        tailf:action purge {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          tailf:info
            "Remove log entries";
          // NCS drop tailf:actionpoint
          description
            "This action requests to delete log entries from the log-entry
             list according to the supplied criteria.";
          input {
            leaf type {
              type ncs:log-entry-t;
            }
            leaf level {
              type ncs:log-entry-level-t;
            }
            container older-than {
              presence "Age specification";
              description
                "Matches the 'when' leaf in the log entry.";
              choice age-spec {
                case seconds {
                  leaf seconds {
                    type uint16;
                  }
                }
                case minutes {
                  leaf minutes {
                    type uint16;
                  }
                }
                case hours {
                  leaf hours {
                    type uint16;
                  }
                }
                case days {
                  leaf days {
                    type uint16;
                  }
                }
                case weeks {
                  leaf weeks {
                    type uint16;
                  }
                }
              }
            }
          }
          output {
            leaf result {
              type string;
            }
            leaf purged-log-entries {
              type uint16;
            }
          }
        }
        list log-entry {
          key "when";
          leaf when {
            type string;
          }
          leaf type {
            description
              "What type of log entry is this.";
            type ncs:log-entry-t;
            // NCS drop mandatory statement
          }
          leaf level {
            description
              "What level this log entry has.";
            type ncs:log-entry-level-t;
            // NCS drop mandatory statement
          }
          leaf message {
            type string;
          }
        }
      }
      leaf name {
        type string;
      }
      list device {
        tailf:info
          "List of devices where OSPF is configured";
        key "name";
        leaf name {
          tailf:info
            "Device name";
          type string;
        }
        list ospfProcess {
          tailf:info
            "OSPF Configuration list";
          key "id";
          leaf id {
            tailf:info
              "OSPF Process ID";
            type uint32;
          }
          leaf ip-address {
            tailf:info
              "OSPF IP address";
            type inet:ipv4-address;
          }
          leaf netmask {
            tailf:info
              "OSPF Netmask";
            type inet:ipv4-address;
          }
          leaf area {
            tailf:info
              "OSPF Area ID";
            type uint32;
          }
        }
      }
    }
  }
  augment "/ncs:devices/ncs:template/ncs:config" {
    list ospf-rfs {
      // NCS patched for predictable order
      ordered-by user;
      key "name";
      // NCS drop config false container modified
      // NCS drop config false container 'directly-modified'
      // NCS drop config false leaf-list 'device-list'
      // NCS drop config false leaf-list 'used-by-customer-service'
      // NCS drop config false container 'commit-queue'
      container private {
        description
          "NCS service related internal data stored here.";
        tailf:hidden "fastmap-private";
        // NCS drop fully hidden leaf 'diff-set'
        // NCS drop fully hidden leaf 'forward-diff-set'
        // NCS drop fully hidden leaf-list 'device-list'
        // NCS drop fully hidden leaf-list 'service-list'
        // NCS drop fully hidden leaf-list 'lsa-service-list'
        container property-list {
          description
            "FASTMAP service instance data used by the service implementation.";
          list property {
            // NCS patched for predictable order
            ordered-by user;
            key "name";
            leaf name {
              type string;
            }
            leaf value {
              type string;
            }
          }
        }
        leaf re-deploy-counter {
          type string;
          // NCS drop default statement
        }
        // NCS drop fully hidden leaf 'latest-commit-params'
        // NCS drop fully hidden leaf 'latest-u-info'
      }
      // NCS drop config false container log
      leaf name {
        type string;
      }
      list device {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        leaf name {
          type string;
        }
        list ospfProcess {
          // NCS patched for predictable order
          ordered-by user;
          key "id";
          leaf id {
            type string;
          }
          leaf ip-address {
            type string;
          }
          leaf netmask {
            type string;
          }
          leaf area {
            type string;
          }
        }
      }
    }
  }
}
